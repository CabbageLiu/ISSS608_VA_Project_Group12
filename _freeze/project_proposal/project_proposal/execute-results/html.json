{
  "hash": "70574d12aad5607a28cdd3ab1588c65e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Project Proposal\"\ndescription: \"\"\nauthor: \"Lui Chih Yuan, David Chiam, Enrico Sebastian\"\ndate: \"8 June 2025\"\ndate-modified: \"last-modified\"\nformat:\n  html: \n    code-fold: true\neditor: visual\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n\n# Take-home Exercise 3: Prototype Module Designing – Community Detection and Pseudonym Network Exploration\n\n## **The Task**\n\nIn this take-home exercise, you are required to select one of the module of your proposed Shiny application and complete the following tasks:\n\n-   To evaluate and determine the necessary R packages needed for your Shiny application are supported in R CRAN,\n-   To prepare and test the specific R codes can be run and returned the correct output as expected,\n-   To determine the parameters and outputs that will be exposed on the Shiny applications, and\n-   To select the appropriate Shiny UI components for exposing the parameters determine above.\n\n-----------------------------------------------------\n\n## **1. Introduction**\n\nThis prototype module is part of a larger visual analytics application for Mini-Challenge 3 (VAST Challenge 2025). It supports investigative journalist **Clepper Jessen** in uncovering hidden relationships and pseudonymous communication patterns within the radio transcript dataset of Oceanus.\n\nThe goal of this prototype is to storyboard and test a modular component that will eventually be integrated into the full Shiny application. The focus is on **community detection** and **interactive pseudonym analysis**, providing users with the ability to dynamically explore clusters of entities based on radio communication activity.\n\nThis document outlines the prototyping process, from data wrangling and method selection, to interactive interface design using Shiny components. The storyboard describes how different visual and interactive elements will work together to support investigative insights.\n\n## **2. Data Preparation**\n\nThe source data is a knowledge graph in JSON format (`MC3_graph.json`) provided in the VAST Challenge 2025 Mini-Challenge 3. It consists of two primary components:\n\n-   **Nodes**: Representing entities such as persons, vessels, places, and roles, each with metadata such as labels and types.\n-   **Edges**: Representing communications between nodes with attributes such as sender, receiver, channel, date-time, and message weight.\n\n### **Pre-processing Steps:**\n\nThe following R packages were used for data wrangling:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidygraph)\nlibrary(ggraph)\nlibrary(jsonlite)\nlibrary(dplyr)\n```\n:::\n\n\n\nThe steps to prepare the data are as follows:\n\n**Step 1: Load and Parse the JSON File**\n\n```         \n# Load the knowledge graph json_graph <- jsonlite::read_json(\"data/MC3_graph.json\")\n```\n\n**Step 2: Extract and Structure Nodes and Edges**\n\n```         \n# Convert to tibble format nodes_tbl <- as_tibble(json_graph$nodes) edges_tbl <- as_tibble(json_graph$links)  # Rename and structure columns for compatibility nodes_tbl <- nodes_tbl %>% rename(id = id, label = name, type = entity_type) edges_tbl <- edges_tbl %>% rename(from = source, to = target)\n```\n\n**Step 3: Convert to a Tidygraph Object**\n\n```         \ngraph_data <- tbl_graph(nodes = nodes_tbl, edges = edges_tbl, directed = TRUE)\n```\n\n**Step 4: Clean and Enrich the Graph**\n\n```         \n# Filter out edges with low weights or irrelevant connections (e.g., self-loops) graph_data <- graph_data %>%    activate(edges) %>%    filter(!is.na(from), !is.na(to)) %>%    filter(weight > 1) %>%    activate(nodes) %>%    mutate(degree = centrality_degree())\n```\n\n**Step 5: Verify Graph Summary**\n\n```         \nsummary(graph_data)\n```\n\nThese steps ensure that the data is converted into a tidy, filterable, and graph-compatible structure for community detection and interactive visualisation.\n\nThe core data transformation principles applied include:\n\n-   **Parsed JSON using tidygraph and igraph** to build a directed graph structure from node-link format.\n-   **Mapped entity metadata** to classify nodes into roles such as Person, Vessel, and Place.\n-   **Filtered and simplified the graph**, including removal of self-loops and edges with insignificant weights to retain only meaningful relationships.\n-   **Enriched nodes with centrality metrics**, particularly degree centrality, which is used for sizing and filtering nodes during visualisation.\n\n## 3. Analytical and Visualisation Techniques\n\nThis module employs a dual-pronged analytical strategy that combines community detection algorithms with exploratory network visualization. These techniques allow the investigator to detect tightly linked communication subgroups, potentially exposing pseudonym clusters or coordinated behavior among vessels and individuals.\n\n### Algorithms Used:\n\nWe adopted two widely recognized algorithms for graph community detection:\n\n-   **Louvain Community Detection**: An unsupervised modularity-based approach that optimizes the partitioning of the graph into clusters. It is computationally efficient and ideal for detecting broad clusters in large-scale networks.\n-   **Walktrap Community Detection**: Uses short random walks to find densely connected subgraphs. It is suitable for identifying smaller, more cohesive communities and capturing subtle relational dynamics.\n\nBoth algorithms produce numeric cluster IDs for each node, which are then used for node coloring and group-based filtering in the visual layer.\n\n### Visualisation Approach:\n\nVisualisation is a central element in this prototype, serving both as an exploratory and explanatory tool. Two main techniques were employed:\n\n-   **Static Graphs using `ggraph`**: These are helpful during the analytical phase for layout calibration, edge density verification, and debugging of network transformations.\n-   **Interactive Graphs using `visNetwork`**: These are deployed in the Shiny UI to support user-driven exploration. `visNetwork` provides pan, zoom, hover, and click functionality, which enhances pattern recognition and contextual analysis.\n\nColor schemes were intentionally chosen to reflect community membership (via cluster ID), and node sizing was mapped to degree centrality to emphasize influence or activity within the graph.\n\nAdditional enhancements include:\n\n-   Hover tooltips to display entity type and communication degree\n-   Legend to distinguish nodes by category (Person, Vessel, Place)\n-   Reactive filtering to isolate specific patterns of interest\n-   **Static Graphs**: Using `ggraph` for initial exploration.\n-   **Interactive Network**: Leveraging `visNetwork` for drilldown, tooltips, and filtering.\n\n## 4. UI Design (Prototyping & Storyboarding)\n\nThis section emphasizes key prototyping principles outlined in the exercise brief:\n\n1.  **Evaluation of R Packages from CRAN**: The prototype uses CRAN-supported packages such as `shiny`, `visNetwork`, `tidygraph`, `ggraph`, `igraph`, `jsonlite`, `dplyr`, and `DT`, all verified as stable and production-ready. This ensures compatibility and reduces technical risk when scaling the full Shiny application.\n\n2.  **Validation of Functional Code**: All prototype components will be individually tested using RStudio. The pre-processing logic and community detection methods seek to ensure that it return correct outputs, and the visual network plot reacts dynamically to filtered inputs. Each Shiny UI input will be tied to a reactive server-side operation, tested both in isolation and in the Shiny runtime environment.\n\n3.  **Definition of Inputs and Outputs**: Inputs include dropdowns for algorithm selection, checkboxes for entity filtering, and sliders for edge weight thresholds. Outputs include an interactive `visNetwork` graph, node information text display, and (optionally) an exportable snapshot. This alignment ensures clarity for both developers and users.\n\n4.  **Shiny UI Component Selection**: Interface components are chosen to balance functionality and user experience:\n\n    -   `selectInput()` offers a clear choice between Louvain and Walktrap algorithms.\n\n    -   `checkboxGroupInput()` allows entity-specific filtering for targeted analysis.\n\n    -   `sliderInput()` provides intuitive numeric filtering for graph density.\n\n    -   `visNetworkOutput()` renders an interactive and scalable network layout.\n\n    -   `verbatimTextOutput()` reveals node metadata for contextual interpretation.\n\nThese choices follow principles showcased in leading prototypes (e.g., Decoding Chaos and Tanzania Tourism), focusing on minimal cognitive load, fast responsiveness, and user-guided discovery.\n\nTo ensure clarity and usability, this module is designed using a storyboard-driven approach, inspired by best practices observed in exemplary prototype pages such as those from *Decoding Chaos* and *Tanzania Tourism Analysis*.\n\n### Prototyping Strategy\n\nDrawing inspiration from these references:\n\n-   Use **incremental prototyping**: starting with static exploration, then layering interactivity.\n-   Implement **modular design**: develop this as one self-contained component for integration into the larger app.\n-   Include **user-centered workflows**: filters and actions modeled after investigative tasks (e.g., discovering who communicates frequently, identifying aliases).\n\n### Storyboarding Process\n\n1.  **Define User Goals**: Support Clepper in uncovering clustered interactions and pseudonym aliases.\n2.  **Storyboard Sketching**: Initial wireframes were drafted to conceptualize component layout — influenced by those in the Decoding Chaos storyboard page.\n3.  **Component-Task Mapping**: Every UI widget was explicitly mapped to a backend logic, ensuring traceability and transparency.\n\n### Planned Layout\n\nThe following storyboard sketch illustrates the intended Shiny module layout. It includes the sidebar controls for algorithm and entity filtering, and the main panel displaying the interactive `visNetwork` output. To ground the design process, we created both a low-fidelity storyboard sketch and a visual Shiny layout mock-up.\n\n-   **Sidebar**: Control panel for selecting algorithm type, filtering entity type, and edge weight.\n-   **Main Panel**: Interactive network with dynamic tooltips, zoom/pan, and metadata inspection.\n-   **Tabbed Interface** *(optional)*: To toggle between community detection algorithms or show temporal comparisons.\n-   **Export & Snapshot Option**: Allow user to capture the view for reporting.\n\n### Main Landing Page Mock-ups and Dashboard Style\n\nTo inform the visual language and layout of the Shiny application, our team designed a prototype landing page comprising several interlinked interface sections. These visuals illustrate the envisioned user interface and serve as references for component development.\n\n#### 1. **Landing Cover Page (Team Identity)**\n\nThis mock-up establishes the visual identity and thematic branding for the dashboard. It reflects both the investigative tone of the VAST Challenge and our team’s creative approach. It includes a left navigation menu that guides users to each of the core question modules (Q1 to Q4), providing a consistent sidebar layout throughout the app.\n\n![](pictures/1.png)\n\n![](pictures/2.png)\n\n#### 2. **Daily Radio Communication Volume (Q1A & Q1B)**\n\nThis section visualizes message frequency over time to detect periodicity or anomalies. It includes:\n\n-   A dynamic bar chart summarizing total and average daily volume.\n-   Interactive dropdown and hover tooltips for contextual exploration.\n\n*This template serves as a reference for time-series visualizations to be integrated in future timeline-driven modules of the application.*\n\n![](pictures/3.png)\n\n#### 3. **Entity Network Focus View – “Nadia Conti” (Q1C)**\n\nThis visual emphasizes network centrality and ego relationships. It includes:\n\n-   Shapes and colors to differentiate entity types (e.g., vessel, organization, person).\n-   A drop-down filter to focus on individual entities.\n\n*This model informed the modular network layout used in our prototype for community and pseudonym analysis.*\n\n![](pictures/4.png)\n\n#### 4. **Storyboard Sketch (Module Wireframe)**\n\nThis low-fidelity layout demonstrates the foundational module structure:\n\n-   Left panel: Parameter controls\n-   Right panel: Interactive graph and metadata display\n\nIt serves as the core layout pattern for the Shiny UI development, supporting Louvain/Walktrap switching, entity filters, and network interactivity.\n\n![](images/clipboard-1365057945.png)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n  titlePanel(\"Community Detection & Pseudonym Explorer\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"algo\", \"Community Detection Algorithm\", choices = c(\"Louvain\", \"Walktrap\")),\n      checkboxGroupInput(\"type\", \"Entity Types\", choices = c(\"Person\", \"Vessel\", \"Place\")),\n      sliderInput(\"weight\", \"Minimum Edge Weight\", min = 1, max = 10, value = 2)\n    ),\n    mainPanel(\n      visNetworkOutput(\"net\", height = \"600px\"),\n      verbatimTextOutput(\"info\")\n    )\n  )\n)\n```\n:::\n\n\n\n### UI Component Mapping\n\n| UI Component | Purpose |\n|----------------------------------|--------------------------------------|\n| `selectInput(\"algo\")` | Choose detection algorithm (Louvain/Walktrap) |\n| `checkboxGroupInput(\"type\")` | Filter node types (person, vessel, place) |\n| `sliderInput(\"weight\")` | Filter connections below weight threshold |\n| `visNetworkOutput(\"net\")` | Display interactive graph |\n| `verbatimTextOutput(\"info\")` | Node metadata panel |\n\n### Design Learnings from References\n\n-   **Tanzania Tourism** emphasized clarity in visual transitions and guided storytelling.\n-   **Decoding Chaos** used a modular dashboard and strong use of aspatial/geospatial splits — we aim to mirror this by making this module fully pluggable.\n-   **Confirmatory Analysis** example showed the benefit of toggling between analytical models — we aim to adopt this in Louvain vs. Walktrap switch.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}